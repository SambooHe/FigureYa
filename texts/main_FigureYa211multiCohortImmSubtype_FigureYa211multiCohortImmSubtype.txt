FigureYa211multiCohortImmSubtype
Code
Show All Code
Hide All Code
FigureYa211multiCohortImmSubtype
Author(s)
: Xiaofan Lu
Reviewers
: Ying Ge,Hui Huang
Date
: 2025-12-25
1
Academic Citation
If you use this code in your work or research, we kindly request that
you cite our publication:
Xiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization
Framework for Enhancing Biomedical Data Interpretation and Research
Efficiency. iMetaMed.
https://doi.org/10.1002/imm3.70005
2
需求描述 Requirement
Description
以往的分子分型都是基于基因表达来做的，这有一个是基于多数据集免疫细胞的，输出Fig.1
A和B。
In the past, molecular typing was based on gene expression, but one
of them is based on multiple datasets of immune cell. Outputs Fig.1 A
and B.
From
https://www.cell.com/molecular-therapy-family/nucleic-acids/fulltext/S2162-2531(20)30259-6
Figure 1. The Landscape of Immuno-cell Infiltration in the TME of
HNSC (A) Unsupervised clustering of tumor-infiltrating immune cells in
five independent HNSC cohorts. Rows represent tumor-infiltrating immune
cells, and columns represent samples. (B) Kaplan-Meier curves for
overall survival (OS) of all HNSC patients with immune cell-infiltrating
classes. Log rank test showed an overall p = 0.018.
跟FigureYa201ClusterCorrelation、FigureYa203ComBat、FigureYa204PCAscore出自同一篇文章。
It’s from the same article as FigureYa201ClusterCorrelation,
FigureYa203ComBat, and FigureYa204PCAscore.
3
应用场景 Application
Scenarios
不同平台的表达谱，去除批次效应后，计算免疫富集，并进行分子分型与生存分析。
Expression profiles of different platforms, after removing batch
effects, immune enrichment was calculated, and molecular typing and
survival analysis were performed.
We performed the CIBERSORT and ESTIMATE algorithms to quantify the
activity or enrichment levels of immune cells in HNSC tumor tissues
4
环境设置 Environment
settings
source
(
"install_dependencies.R"
)
library
(sva)
# ComBat去除批次效应 # ComBat removes batch effects
library
(ConsensusClusterPlus)
# 共识聚类 # Consensus clustering
library
(survminer)
# 生存分析 # Survival analysis
library
(survival)
# 生存分析 # Survival analysis
library
(tidyestimate)
# 计算ESTIMATE得分 # Calculate ESTIMATE score (replaces old estimate package)
library
(pheatmap)
# 热图 # Heatmap
source
(
"CIBERSORT.R"
)
Sys.setenv
(
LANGUAGE =
"en"
)
#显示英文报错信息 # error messages are displayed in English
options
(
stringsAsFactors =
FALSE
)
#禁止chr转成factor # chr is not allowed to be converted to factor
自定义函数，用于数据标准化并截断极端值 Custom functions for data
normalization and truncation of extreme values
standarize.fun
<-
function
(
indata=
NULL
,
halfwidth=
NULL
,
centerFlag=
T,
scaleFlag=
T) {
outdata
=
t
(
scale
(
t
(indata),
center=
centerFlag,
scale=
scaleFlag))
if
(
!
is.null
(halfwidth)) {
outdata[outdata
>
halfwidth]
=
halfwidth
outdata[outdata
<
(
-
halfwidth)]
=
-
halfwidth
}
return
(outdata)
}
5
输入文件 Input
files
表达矩阵文件，数据下载和预处理可参考FigureYa203ComBat。
TCGA
hnsc的表达数据和生存信息：tcga_hnsc.expr.txt和tcga_hnsc.surv.txt。可以用TCGAbiolinks下载，或从
xena
下载。
来自GEO的芯片数据和生存信息：gse41613.expr.txt和gse41613.surv.txt，gse65858.expr.txt和gse65858.surv.txt
The expression matrix file, the data download and preprocessing can
be found in FigureYa203ComBat.
Expression data and survival information :tcga_hnsc.expr.txt and
tcga_hnsc.surv.txt of TCGA hnsc. It can be downloaded with TCGAbiolinks,
or from
xena
Chip data and survival information from
GEO:gse41613.expr.txt
and
gse41613.surv.txt, gse65858.expr.txt and gse65858.surv.txt
5.1
加载不同平台的表达谱、去除批次效应 Load expression profiles from
different platforms to remove batch effects
# 加载预处理过的表达谱
# Load the pre-treated expression spectrum
tcga.expr
<-
read.csv
(
"tcga_hnsc.expr.txt"
,
sep =
"
\t
"
,
row.names =
1
,
check.names =
F,
stringsAsFactors =
F,
header =
T)
gse41613.expr
<-
read.table
(
"gse41613.expr.txt"
,
sep =
"
\t
"
,
row.names =
1
,
check.names =
F,
stringsAsFactors =
F,
header =
T)
gse65858.expr
<-
read.table
(
"gse65858.expr.txt"
,
sep =
"
\t
"
,
row.names =
1
,
check.names =
F,
stringsAsFactors =
F,
header =
T)
# 检查数据量级
# Check the amount of data
range
(tcga.expr)
# 量级很大取对数 # The magnitude is very large and logarithm
tcga.expr
<-
log2
(tcga.expr
+
1
)
range
(tcga.expr)
# 量级在0-20 # On the magnitude of 0-20
range
(gse41613.expr)
# 量级在0-20 # On the magnitude of 0-20
range
(gse65858.expr)
# 量级在0-20 # On the magnitude of 0-20
# 合并数据集检查批次效应
# Merge datasets to check batch effect
comgene
<-
intersect
(
intersect
(
rownames
(tcga.expr),
rownames
(gse41613.expr)),
rownames
(gse65858.expr))
combined.expr
<-
cbind.data.frame
(tcga.expr[comgene,],
gse41613.expr[comgene,],
gse65858.expr[comgene,])
# combat去除批次再次检查
# combat remove the batch and check it again
batch
<-
data.frame
(
batch =
rep
(
c
(
"TCGA"
,
"GSE41613"
,
"GSE65858"
),
times =
c
(
ncol
(tcga.expr),
ncol
(gse41613.expr),
ncol
(gse65858.expr))))
modcombat
=
model.matrix
(
~
1
,
data =
batch)
combined.expr.combat
<-
as.data.frame
(
ComBat
(
dat=
as.matrix
(combined.expr),
batch=
batch
$
batch,
mod=
modcombat))
# 保存到txt格式的文件
# Save to a file in txt format
write.table
(combined.expr.combat,
"output_combined_expr.txt"
,
sep =
"
\t
"
,
row.names =
T,
col.names =
NA
,
quote =
F)
5.2
加载生存数据，用于生存分析 Load survival data for survival analysis
tcga.surv
<-
read.table
(
"tcga_hnsc.surv.txt"
,
sep =
"
\t
"
,
row.names =
1
,
check.names =
F,
stringsAsFactors =
F,
header =
T)
tcga.surv
<-
as.data.frame
(
na.omit
(tcga.surv))
# 去除空值 # Remove null values
rownames
(tcga.surv)
<-
paste0
(
rownames
(tcga.surv),
"-01"
)
gse41613.surv
<-
read.table
(
"gse41613.surv.txt"
,
sep =
"
\t
"
,
row.names =
1
,
check.names =
F,
stringsAsFactors =
F,
header =
T)
gse65858.surv
<-
read.table
(
"gse65858.surv.txt"
,
sep =
"
\t
"
,
row.names =
1
,
check.names =
F,
stringsAsFactors =
F,
header =
T)
# 根据数据将时间转化为月份
# Convert time to months based on data
tcga.surv
$
OS.time
<-
tcga.surv
$
OS.time
/
30.5
gse65858.surv
$
OS.time
<-
gse65858.surv
$
OS.time
/
30.5
# 合并生存时间
# Merge time-to-live
tcga.surv
$
Project
<-
"TCGA"
gse41613.surv
$
Project
<-
"GSE41613"
gse65858.surv
$
Project
<-
"GSE65858"
combined.surv
<-
rbind.data.frame
(tcga.surv[,
c
(
"OS"
,
"OS.time"
,
"Project"
)],
gse41613.surv[,
c
(
"OS"
,
"OS.time"
,
"Project"
)],
gse65858.surv[,
c
(
"OS"
,
"OS.time"
,
"Project"
)])
6
计算ESTIMATE得分
Calculate ESTIMATE score
output_combined_expr.csv，上一步整合好的表达矩阵和生存信息。
output_combined_expr.csv, the previous step integrates the expression
matrix and survival information.
使用tidyestimate包计算得分 (替代旧的estimate包)。
Use tidyestimate package to calculate scores (replaces old estimate
package).
# 读取表达矩阵 # Read expression matrix
combined.expr.combat
<-
read.table
(
"output_combined_expr.txt"
,
sep =
"
\t
"
,
row.names =
1
,
check.names =
F,
stringsAsFactors =
F,
header =
T)
# 使用tidyestimate包计算得分 # Use tidyestimate package to calculate scores
# 当tidy=FALSE时，基因标识符在行名中 # When tidy=FALSE, gene identifiers are in rownames
filtered_data
<-
filter_common_genes
(combined.expr.combat,
id =
"hgnc_symbol"
,
tidy =
FALSE
,
tell_missing =
TRUE
,
find_alias =
FALSE
)
# 计算ESTIMATE得分 # Calculate ESTIMATE scores
est.result
<-
estimate_score
(filtered_data,
is_affymetrix =
FALSE
)
# 使用合并数据，通常不是Affymetrix平台 # Using merged data, usually not Affymetrix platform
# 转换数据格式为兼容后续分析的格式 # Convert data format for compatibility with subsequent analysis
# estimate_score返回格式：sample, stromal, immune, estimate
# 需要转置为：行=得分类型，列=样本 # Need to transpose to: rows=score types, columns=samples
sample_names
<-
est.result
$
sample
est.result
<-
est.result[,
c
(
"stromal"
,
"immune"
,
"estimate"
)]
# 只选择数值列 # Select only numeric columns
est.result
<-
t
(est.result)
# 转置 # Transpose
rownames
(est.result)
<-
c
(
"StromalScore"
,
"ImmuneScore"
,
"ESTIMATEScore"
)
colnames
(est.result)
<-
sample_names
# 保存结果到文件 # Save results to file
write.table
(est.result,
"output_combined_expr_estimate_score.txt"
,
sep =
"
\t
"
,
row.names =
T,
col.names =
NA
,
quote =
F)
7
Run CIBERSORT
原文：Infiltration levels for distinct immune cells in HNSC were
quantified by using “CIBERSORT” R package and employing the LM22
signature and 1,000 permutations.
使用CIBERSORT前，请先注册
https://cibersort.stanford.edu
，查看教程
http://cibersort.stanford.edu/tutorial.php
LM22.txt，注册后即可下载。
original paper:Infiltration levels for distinct immune cells in HNSC
were quantified by using “CIBERSORT” R package and employing the LM22
signature and 1,000 permutations.
before use CIBERSORT Please register for
https://cibersort.stanford.edu
first to view the
tutorial
http://cibersort.stanford.edu/tutorial.php
LM22.txt, you can download it after registration.
output_combined_expr.txt，上一步整合好的表达矩阵和生存信息。
output_combined_expr.txt, the previous step integrates the
expression matrix and survival information.
#这步运行时间较长
# This step takes a long time to run
ciber.res
<-
CIBERSORT
(
sig_matrix =
"LM22.txt"
,
mixture_file =
"output_combined_expr.txt"
,
perm =
100
,
QN =
TRUE
)
# 保存到文件
# Save to file
write.table
(ciber.res,
"CIBERSORT result.txt"
,
sep =
"
\t
"
,
row.names =
T,
col.names =
NA
,
quote =
F)
8
共识PAM聚类 Consensus
PAM clustering
The unsupervised clustering “Pam” method based on Euclidean and
Ward’s linkage was used in this analysis, executed by using the
“ConsensuClusterPlus” R package,23 and repeated 1,000 times to ensure
the classification stability.
est
<-
read.table
(
"output_combined_expr_estimate_score.txt"
,
sep =
"
\t
"
,
row.names =
1
,
check.names =
F,
stringsAsFactors =
F,
header =
T)
# tidyestimate输出的格式已经正确，不需要再处理 # tidyestimate output format is already correct, no need for additional processing
# 列名应该已经是正确的样本名 # Column names should already be correct sample names
ciber.res
<-
read.table
(
"CIBERSORT result.txt"
,
sep =
"
\t
"
,
row.names =
1
,
header =
T,
check.names =
F)
head
(ciber.res)
# 合并ESTIMATE获得的activity of immune cells(est)和CIBERSORT获得的enrichment levels of immune cells(ciber.res)
# Merge the activity of immune cells (est) obtained from ESTIMATE and the enrichment levels of immune cells obtained by CIBERSORT (ciber.res)
ciber.res
<-
ciber.res[,
1
:
22
]
ciber.res
<-
ciber.res[,
colSums
(ciber.res)
>
0
]
# 去除丰度均为0的细胞 # Remove cells with 0 abundance
input_data
<-
cbind.data.frame
(ciber.res,
ImmuneScore =
as.numeric
(est[
"ImmuneScore"
,
rownames
(ciber.res)]),
# 添加免疫富集 # Add immune enrichment
StromalScore =
as.numeric
(est[
"StromalScore"
,
rownames
(ciber.res)]))
# 添加基质富集 # Add matrix enrichment
indata
<-
t
(
scale
(input_data))
# 这一步，我运行了 < 10 min
# For this step, I ran < for 10 min
cc
<-
ConsensusClusterPlus
(
d =
indata,
maxK =
3
,
# 三类 # Three categories
reps =
1000
,
# 重抽样次数，可修改 # Number of resamples, modifiable
pItem =
0.8
,
# 列维度抽样概率，可修改 # Column dimension sampling probability, modifiable
pFeature =
1
,
# 行维度抽样概率，可修改 # Row dimension sampling probability, modifiable
clusterAlg =
"pam"
,
# 聚类算法，可修改 # Clustering algorithm, modifiable
innerLinkage =
"ward.D"
,
# 内部链接函数，可修改 # Internal link function, modifiable
finalLinkage =
"ward.D"
,
# 最终链接函数，可修改 # Last-link function, modifiable
distance =
"euclidean"
,
# 距离测度，可修改 # Distance measurement, modifiable
seed =
19991018
,
title =
"ConsensusCluster"
,
plot =
"pdf"
)
ICIcluster
<-
cc[[
3
]]
$
consensusClass
# 为生存分析作准备
# Prepare for survival analysis
comsam
<-
intersect
(
rownames
(combined.surv),
colnames
(indata))
combined.surv[comsam,
"ICIcluster"
]
<-
ifelse
(ICIcluster[comsam]
==
1
,
"A"
,
# 这里把有生存信息的数据的ICIcluster补上以便后面进行生存分析 # # Here we add the ICIcluster with survival information for survival analysis later
ifelse
(ICIcluster[comsam]
==
2
,
"B"
,
"C"
))
9
开始画图 Start
drawing
9.1
热图 Heatmap
# 设置颜色
# Set the color
blue
<-
"#2874C5"
yellow
<-
"#EABF00"
green
<-
"#008B8A"
red
<-
"#E21F26"
# 生成热图
# Generate a heatmap
annCol
<-
data.frame
(
ICIcluster =
ifelse
(ICIcluster
==
1
,
"A"
,
ifelse
(ICIcluster
==
2
,
"B"
,
"C"
)),
Project =
rep
(
c
(
"TCGA"
,
"GSE41613"
,
"GSE65858"
),
c
(
ncol
(tcga.expr),
ncol
(gse41613.expr),
ncol
(gse65858.expr))),
stringsAsFactors =
F)
annCol
<-
annCol[
order
(annCol
$
ICIcluster,annCol
$
Project),]
# 这里对每个ICIcluster内部的cohort进行排序，使得相同cohort的样本彼此靠近 # Here the cohorts inside each ICIcluster are sorted so that the samples of the same cohort are close to each other
annColors
<-
list
()
annColors[[
"ICIcluster"
]]
<-
c
(
"A"
=
red,
"B"
=
blue,
"C"
=
yellow)
annColors[[
"Project"
]]
<-
c
(
"TCGA"
=
red,
"GSE41613"
=
blue,
"GSE65858"
=
yellow)
plotdata
<-
standarize.fun
(indata,
halfwidth =
2
)
# 数据标准化并截断极端值 # Data is normalized and truncated to extreme values
pheatmap
(plotdata[,
rownames
(annCol)],
cluster_cols =
F,
color =
colorRampPalette
(
c
(
"#282B71"
,
"white"
,
"#CF2221"
))(
64
),
# 使用现代colorRampPalette替代NMF:::ccRamp # Use modern colorRampPalette instead of NMF:::ccRamp
show_rownames =
T,
show_colnames =
F,
annotation_col =
annCol[,
c
(
"ICIcluster"
,
"Project"
),
drop =
F],
annotation_colors =
annColors,
treeheight_col =
0
,
treeheight_row =
0
,
filename =
"ICIcluster.pdf"
)
9.2
生存分析 Survival
Analysis
fitd
<-
survdiff
(
Surv
(OS.time, OS)
~
ICIcluster,
data      =
combined.surv,
na.action =
na.exclude)
p.val
<-
1
-
pchisq
(fitd
$
chisq,
length
(fitd
$
n)
-
1
)
fit
<-
survfit
(
Surv
(OS.time, OS)
~
ICIcluster,
data      =
combined.surv,
type      =
"kaplan-meier"
,
error     =
"greenwood"
,
conf.type =
"plain"
,
na.action =
na.exclude)
# hack strata for better survival curve
names
(fit
$
strata)
<-
gsub
(
"ICIcluster="
,
""
,
names
(fit
$
strata))
# kaplan-meier curve
p
<-
ggsurvplot
(
fit               =
fit,
conf.int          =
FALSE
,
risk.table        =
TRUE
,
risk.table.col    =
"strata"
,
palette           =
c
(red, blue, yellow),
data              =
combined.surv,
size              =
1
,
xlim              =
c
(
0
,
120
),
break.time.by     =
20
,
legend.title      =
""
,
pval              =
FALSE
,
# 不计算p值，改为手动添加 # The p-value is not calculated, and is added manually
surv.median.line  =
"hv"
,
xlab              =
"Time (month)"
,
ylab              =
"Survival probability"
,
risk.table.y.text =
FALSE
)
p.lab
<-
paste0
(
"Log rank test P"
,
# p值文本 # P-value text
ifelse
(p.val
<
0.001
,
" < 0.001"
,
paste0
(
" = "
,
round
(p.val,
3
))))
p
$
plot
<-
p
$
plot
+
annotate
(
"text"
,
# 手动添加例文样式的p值 # Manually add the p-value of the example style
x =
70
,
y =
0.55
,
hjust =
0
,
fontface =
4
,
label =
p.lab)
p
$
plot
pdf.options
(
reset =
TRUE
,
onefile =
FALSE
)
pdf
(
"km curve of ICIcluster.pdf"
,
width =
5
,
height =
6
)
print
(p)
dev.off
()
10
关键更新要点 Key
Updates Summary
依赖包现代化
：替换旧的
estimate
包为新的
tidyestimate
包，使用
filter_common_genes
和
estimate_score
函数替代旧的
filterCommonGenes
和
estimateScore
函数名称更新
：tidyestimate使用现代R命名规范（snake_case），与旧estimate包的camelCase命名不同
数据格式兼容性
：tidyestimate要求当
tidy=FALSE
时基因标识符在行名中，输出格式为tibble，需要适当的格式转换（移除了旧代码中不必要的列名处理）
平台检测改进
：使用
is_affymetrix
参数替代
platform
参数，更清晰地指定数据平台类型（TRUE/FALSE 代替字符串）
颜色函数现代化
：替换过时的
NMF:::ccRamp
函数为现代的
colorRampPalette
，确保与新R版本的兼容性，避免对已废弃NMF包的依赖
Dependency Modernization
: Replaced the
deprecated
estimate
package with the modern
tidyestimate
package, using
filter_common_genes
and
estimate_score
functions instead of the old
filterCommonGenes
and
estimateScore
Function Name Updates
: tidyestimate uses modern
R naming conventions (snake_case), different from the old estimate
package’s camelCase naming
Data Format Compatibility
: tidyestimate requires
gene identifiers in rownames when
tidy=FALSE
, and returns
tibble format requiring appropriate conversions (removed unnecessary
column name processing from old code)
Platform Detection Improvements
: Uses
is_affymetrix
parameter (TRUE/FALSE) instead of
platform
parameter (string) for clearer data platform
specification
Color Function Modernization
: Replaced the
outdated
NMF:::ccRamp
function with modern
colorRampPalette
to ensure compatibility with newer R
versions and avoid dependency on deprecated NMF package
11
Session Info
sessionInfo
()